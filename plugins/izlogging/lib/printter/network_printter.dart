import 'dart:convert';
import 'dart:math';
import 'package:logger/logger.dart';
import 'package:logger/web.dart';

class NetworkErrorPrinter extends LogPrinter {
  static const lineLength = 120;
  static const divider = '═';
  static const subDivider = '─';
  static const corner = '╔ςυρ';
  static const middleCorner = '╟';
  static const bottomCorner = '╚';
  static const verticalLine = '║';
  String topBorder = '$corner${divider * (lineLength - 1)}';
  String middleBorder = '$middleCorner${subDivider * (lineLength - 1)}';
  String bottomBorder = '$bottomCorner${divider * (lineLength - 1)}';

  final bool colored;

  static final Map<Level, AnsiColor> defaultLevelColors = {
    Level.trace: AnsiColor.fg(AnsiColor.grey(0.5)),
    Level.debug: const AnsiColor.none(),
    Level.info: const AnsiColor.fg(12),
    Level.warning: const AnsiColor.fg(208),
    Level.error: const AnsiColor.fg(196),
    Level.fatal: const AnsiColor.fg(199),
  };

  /// The index of the first line of the stack trace to include
  final List<String> excludePaths = [];

  /// Matches a stacktrace line as generated on Android/iOS devices.
  ///
  /// For example:
  /// * #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((\S+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  ///
  /// For example:
  /// * packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

  /// Matches a stacktrace line as generated by browser Dart.
  ///
  /// For example:
  /// * dart:sdk_internal
  /// * package:logger/src/logger.dart
  static final _browserStackTraceRegex = RegExp(r'^(?:package:)?(dart:\S+|\S+)');

  NetworkErrorPrinter({this.colored = false});

  @override
  List<String> log(LogEvent event) {
    final Map<String, dynamic> details = event.message as Map<String, dynamic>;

    List<String> buffer = [];
    final color = _getLevelColor(event.level);
    if (event.level == Level.error) {
      String stackTraceStr = '';
      if (event.error != null) {
        stackTraceStr = formatStackTrace(event.stackTrace ?? StackTrace.current, 10) ?? '';
      }
      buffer.add(color(topBorder));
      buffer.add(color('$verticalLine NETWORK ERROR'));
      if (stackTraceStr.isNotEmpty) {
        buffer.add(color(middleBorder));
        buffer.add(color(stackTraceStr));
      }
    } else {
      buffer.add(color(topBorder));
      buffer.add(color('$verticalLine NETWORK INFO'));
    }

    buffer.add(color(middleBorder));
    buffer.addAll(_formatDetails(details, color: color));
    if (event.level == Level.error) {
      buffer.add(color(middleBorder));
      buffer.addAll(_formatCurlCommand(details, color: color));
    }
    buffer.add(color(bottomBorder));

    return buffer;
  }

  AnsiColor _getLevelColor(Level level) {
    if (!colored) {
      return const AnsiColor.none();
    }
    AnsiColor? color = defaultLevelColors[level];
    return color ?? const AnsiColor.none();
  }

  List<String> _formatDetails(Map<String, dynamic> details, {AnsiColor color = const AnsiColor.none()}) {
    List<String> formattedDetails = [];
    formattedDetails.add(color('$verticalLine URL: ${details['url']}'));
    formattedDetails.add(color('$verticalLine Method: ${details['method']}'));
    formattedDetails.add(color('$verticalLine Headers: ${jsonEncode(details['headers'])}'));
    formattedDetails.add(color('$verticalLine Status code: ${details['statusCode']}'));
    formattedDetails.add(color('$verticalLine Body request: ${details['bodyRequest'] ?? 'N/A'}'));
    formattedDetails.add(color('$verticalLine Body Response: ${details['bodyResponse'] ?? 'N/A'}'));
    return formattedDetails;
  }

  List<String> _formatCurlCommand(Map<String, dynamic> details, {AnsiColor color = const AnsiColor.none()}) {
    final headers = details['headers'] as Map<String, dynamic>;
    final headerStrings = headers.entries.map((entry) => '-H "${entry.key}: ${entry.value}"').join(' ');
    final bodyRequest = details['bodyRequest'] as Map<String, dynamic>?;
    String? bodyString;
    // Convertendo o bodyRequest para JSON
    if (bodyRequest != null) {
      bodyString = jsonEncode(bodyRequest);
    }

    final green = colored ? const AnsiColor.fg(34) : const AnsiColor.none();

    return [
      '${color(verticalLine)} ${green(' TO RETRY THIS USE:')}',
      color(middleBorder),
      green(
          '  curl -X ${details['method']} $headerStrings -d ${bodyString != null ? '\'$bodyString\'' : ''} ${details['url']}'),
    ];
  }

  String? formatStackTrace(StackTrace? stackTrace, int? methodCount) {
    List<String> lines = stackTrace
        .toString()
        .split('\n')
        .where(
          (line) =>
              !_discardDeviceStacktraceLine(line) &&
              !_discardWebStacktraceLine(line) &&
              !_discardBrowserStacktraceLine(line) &&
              line.isNotEmpty,
        )
        .toList();
    List<String> formatted = [];

    int stackTraceLength = (methodCount != null ? min(lines.length, methodCount) : lines.length);
    for (int count = 2; count < stackTraceLength; count++) {
      var line = lines[count];

      formatted.add('$verticalLine #${count - 2}   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(2)!;
    if (segment.startsWith('package:logger')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    if (segment.startsWith('packages/logger') || segment.startsWith('dart-sdk/lib')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  bool _discardBrowserStacktraceLine(String line) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    if (segment.startsWith('package:logger') || segment.startsWith('dart:')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  bool _isInExcludePaths(String segment) {
    for (var element in excludePaths) {
      if (segment.startsWith(element)) {
        return true;
      }
    }
    return false;
  }
}
